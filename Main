#include <Arduino.h>
#include <FastLED.h>
#include <LEDMatrix.h>
#include <LEDText.h>
#include <FontMatrise.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "time.h"
#include "joystickLib.h"
#include <DHT.h>

// Task-Handles mit erhöhter Stack-Größe
TaskHandle_t SnakeGameTaskHandle = NULL;
TaskHandle_t WetterTaskHandle = NULL;
TaskHandle_t UhrzeitTaskHandle = NULL;
TaskHandle_t DHTTaskHandle = NULL;
TaskHandle_t MenuTaskHandle = NULL;

// Taster-Objekt (Pins: 32, 34, 35)
EntprellterTaster taster(32, 34, 35);

// DHT22 Sensor Setup
#define DHTPIN 21
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);

// Aktuelle Task-Nummer
volatile int aktuelleTaskNummer = 0;

// WLAN-Zugangsdaten
const char* ssid = "FITZ!Box 7590 HN";
const char* password = "fitzinger";

// NTP-Server für Uhrzeitanzeige (Task C)
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 3600; // GMT+1
const int daylightOffset_sec = 3600; // Sommerzeit

// OpenWeatherMap-API-Details für Wetteranzeige (Task B)
const char* weatherApiKey = "965631ef20117397bfee0d02ee665406";
const char* city = "Innsbruck";
const char* weatherApiUrl = "http://api.openweathermap.org/data/2.5/weather?q=Innsbruck&appid=";

// Webhook-URL für DHTTask
const char* webhookUrl = "https://script.google.com/macros/s/AKfycbyH1J5bwt9Jv1lmUOqEWj-NJBnUZ2gF7XvtkgZbwpSiixqovzjH4-XWufLUBbi6iHk/exec";

// Matrix Definitionen
#define LED_PIN_UPPER   25  // Oberes Panel
#define LED_PIN_LOWER   26  // Unteres Panel
#define COLOR_ORDER     GRB
#define CHIPSET         WS2812B

#define MATRIX_WIDTH    32
#define MATRIX_HEIGHT   8
#define MATRIX_TYPE     VERTICAL_ZIGZAG_MATRIX

// Zwei separate LED-Matrizen definieren
cLEDMatrix<MATRIX_WIDTH, -MATRIX_HEIGHT, MATRIX_TYPE> upperMatrix;
cLEDMatrix<-MATRIX_WIDTH, MATRIX_HEIGHT, MATRIX_TYPE> lowerMatrix;

// Zwei separate Scrolling-Textobjekte
cLEDText upperScrollingMsg;
cLEDText lowerScrollingMsg;

// Buffer für die anzuzeigenden Texte
unsigned char upperTextBuffer[75]; 
unsigned char lowerTextBuffer[75]; 
int upperTextLength = 0;
int lowerTextLength = 0;

// Timer für verschiedene Aktualisierungsintervalle
unsigned long lastWeatherUpdate = 0;
unsigned long lastTimeUpdate = 0;
unsigned long lastScrollUpdate = 0;
unsigned long lastSensorRead = 0;
const unsigned long weatherUpdateInterval = 60000; // Wetterupdate alle 60 Sekunden
const unsigned long timeUpdateInterval = 1000;     // Zeitupdate jede Sekunde
const unsigned long scrollUpdateInterval = 100;    // Basis-Scrolling-Intervall
const unsigned long sensorReadInterval = 5000;     // Sensor alle 5 Sekunden auslesen

// Variable zum Speichern der Wetterdaten (Task B)
float temperature = 0.0;
String weatherDescription = "";
bool neueTemperaturVerfuegbar = false;
float letzteAngezeigeTemperatur = -999.0; // Unmöglicher Wert als Initial

// Variable zum Verfolgen der Scrollposition
int upperScrollCount = 0;
int lowerScrollCount = 0;
int upperTextWidth = 0;
int lowerTextWidth = 0;
bool textNeedsUpdate = false;
bool upperScrollCompleted = false;
bool lowerScrollCompleted = false;

// Sensor-Status Variablen für nicht-blockierendes Lesen (DHTTask)
bool sensorReadRequested = false;
unsigned long sensorRequestTime = 0;
const unsigned long sensorReadDelay = 10; // Minimale Wartezeit zwischen Anfrage und Lesen

// Variable zum Speichern der aktuellen DHT-Temperatur
float aktuelleTemperatur = 0.0;
bool temperaturVerfuegbar = false;

// Semaphore für den Zugriff auf die LED-Matrix - KRITISCH für Thread-Sicherheit
SemaphoreHandle_t ledMatrixSemaphore = NULL;

// Zusätzliche Synchronisation für Task-Wechsel
SemaphoreHandle_t taskSwitchSemaphore = NULL;

// Flag um sicherzustellen, dass nur eine Task gleichzeitig die LEDs verwendet
volatile bool ledUpdateInProgress = false;

// ====================== SNAKE GAME VARIABLEN ======================
#define SNAKE_BRIGHTNESS  50
#define SNAKE_DEADZONE    600
#define SNAKE_BORDER_SIZE 1

struct Point {
  int x;
  int y;
};

Point snake[512];
int snakeLength = 3;
int dirX = 1;
int dirY = 0;
Point food;

unsigned long lastMoveTime = 0;
unsigned long moveInterval = 200;
unsigned long respawnTime = 0;
bool gameOver = false;
unsigned long respawnDelay = 1000;

// ====================== THREAD-SICHERE LED FUNKTIONEN ======================

// Thread-sichere Funktion zum Löschen aller LEDs
void safeClearLEDs() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    FastLED.clear();
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

// Thread-sichere Funktion zum Anzeigen der LEDs
void safeShowLEDs() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    if (!ledUpdateInProgress) {
      FastLED.show();
    }
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

// ====================== FUNKTIONEN ======================

// Aktualisierung der Scroll-Position für beide Panels - THREAD-SICHER
void updateScrollText() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Update oberes Panel
    upperScrollingMsg.UpdateText();
    upperScrollCount++;

    // Update unteres Panel
    lowerScrollingMsg.UpdateText();
    lowerScrollCount++;

    // Unterschiedliche Scroll-Reset-Grenzen je nach aktivem Task
    int upperResetLimit;
    int lowerResetLimit;

    switch (aktuelleTaskNummer) {
      case 1: // Task B (Wetter)
        upperResetLimit = upperTextWidth + MATRIX_WIDTH - 45;
        lowerResetLimit = lowerTextWidth + MATRIX_WIDTH - 30;
        break;
      case 2: // Task C (Uhrzeit)
        upperResetLimit = upperTextWidth + MATRIX_WIDTH-32;
        lowerResetLimit = lowerTextWidth + MATRIX_WIDTH-31;
        break;
      case 3: // DHTTask
        upperResetLimit = upperTextWidth + MATRIX_WIDTH-32;
        lowerResetLimit = lowerTextWidth + MATRIX_WIDTH - 30;
        break;
      default: // Snake Game
        ledUpdateInProgress = false;
        xSemaphoreGive(ledMatrixSemaphore);
        return; // Kein Scrolling für Snake Game
    }

    // Scroll-Reset nur wenn der gesamte Text durchgelaufen ist
    if (aktuelleTaskNummer != 3 && upperScrollCount >= upperResetLimit) {
      upperScrollCount = 0;
      upperScrollCompleted = true;
      upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
    }

    if (lowerScrollCount >= lowerResetLimit) {
      lowerScrollCount = 0;
      lowerScrollCompleted = true;
      lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
    }
    
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

// ================= TASK B: WETTER-FUNKTIONEN =================

void updateWeather() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String url = String(weatherApiUrl) + weatherApiKey;
    http.begin(url);
    int httpResponseCode = http.GET();

    if (httpResponseCode == 200) {
      String payload = http.getString();
      Serial.println("Wetterdaten empfangen:");
      parseWeather(payload);
    } else {
      Serial.printf("Fehler beim Abrufen der Wetterdaten: HTTP %d\n", httpResponseCode);
    }
    http.end();
  } else {
    Serial.println("Nicht mit dem WLAN verbunden.");
  }
}

void parseWeather(const String& json) {
  StaticJsonDocument<1024> doc;
  DeserializationError error = deserializeJson(doc, json);

  if (error) {
    Serial.println("Fehler beim Parsen der JSON-Daten.");
    return;
  }

  // Wetterbeschreibung auslesen
  weatherDescription = doc["weather"][0]["description"].as<String>();

  // Temperatur als float auslesen
  temperature = doc["main"]["temp"].as<float>() - 273.15; // Kelvin in Celsius umrechnen

  // Ausgabe im Serial Monitor
  Serial.printf("Wetter: %s\n", weatherDescription.c_str());
  Serial.printf("Temperatur: %.2f °C\n", temperature);
  
  // Markiere, dass wir ein Update des Textes benötigen
  textNeedsUpdate = true;
}

void updateDisplayWithWeather() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Text für oberes Panel (Temperatur) formatieren
    char tempText[75];
    sprintf(tempText, "      %.1f°C", temperature);
    
    // Text für unteres Panel (Wetter) formatieren
    char weatherText[75];
    sprintf(weatherText, "      %s", weatherDescription.c_str());
    
    // Texte für LED-Matrizen setzen
    strcpy((char*)upperTextBuffer, tempText);
    strcpy((char*)lowerTextBuffer, weatherText);
    upperTextLength = strlen((char*)upperTextBuffer);
    lowerTextLength = strlen((char*)lowerTextBuffer);
    
    // Berechne die ungefähre Breite der Texte
    upperTextWidth = upperTextLength * 6;
    lowerTextWidth = lowerTextLength * 6;
    
    // Setze neuen Text nur, wenn der vorherige Text vollständig gescrollt wurde
    // oder wenn wir gerade das erste Update durchführen
    if (upperScrollCompleted || upperScrollCount == 0) {
      upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
      upperScrollCount = 0;
      upperScrollCompleted = false;
    }
    
    if (lowerScrollCompleted || lowerScrollCount == 0) {
      lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
      lowerScrollCount = 0;
      lowerScrollCompleted = false;
    }
    
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

// ================= TASK C: UHRZEIT-FUNKTIONEN =================

void updateTimeDisplay() {
  struct tm timeInfo;
  if (getLocalTime(&timeInfo)) {
    if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
      ledUpdateInProgress = true;
      
      // Text für oberes Panel (Uhrzeit) formatieren
      char timeText[75];
      sprintf(timeText, "      %02d:%02d:%02d", 
              timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
      
      // Text für unteres Panel (Datum) formatieren
      char dateText[75];
      sprintf(dateText, "      %02d.%02d.%04d",
              timeInfo.tm_mday, timeInfo.tm_mon + 1, timeInfo.tm_year + 1900);
      
      // Prüfen ob sich der Text geändert hat (um unnötige Resets zu vermeiden)
      bool upperTextChanged = (strcmp((char*)upperTextBuffer, timeText) != 0);
      bool lowerTextChanged = (strcmp((char*)lowerTextBuffer, dateText) != 0);
      
      // Texte für LED-Matrizen setzen
      strcpy((char*)upperTextBuffer, timeText);
      strcpy((char*)lowerTextBuffer, dateText);
      upperTextLength = strlen((char*)upperTextBuffer);
      lowerTextLength = strlen((char*)lowerTextBuffer);
      
      // Berechne die ungefähre Breite der Texte
      upperTextWidth = upperTextLength * 6;
      lowerTextWidth = lowerTextLength * 6;
      
      // Setze neuen Text nur wenn:
      // 1. Das erste Update ist (upperScrollCount == 0)
      // 2. Der Text sich geändert hat UND ein vollständiger Scroll-Durchgang abgeschlossen ist
      if (upperScrollCount == 0 || (upperTextChanged && upperScrollCompleted)) {
        upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
        upperScrollCount = 0;
        upperScrollCompleted = false;
      }
      
      if (lowerScrollCount == 0 || (lowerTextChanged && lowerScrollCompleted)) {
        lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
        lowerScrollCount = 0;
        lowerScrollCompleted = false;
      }
      
      ledUpdateInProgress = false;
      xSemaphoreGive(ledMatrixSemaphore);
    }
  } else {
    Serial.println("Fehler beim Abrufen der Zeit");
  }
}

// ================= DHT TASK FUNKTIONEN =================

void sendeDaten(float temperatur) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String url = String(webhookUrl) + "?temperatur=" + temperatur;
    
    http.begin(url);
    
    // Folge Umleitungen automatisch
    http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
    
    // Setze User-Agent (manchmal erforderlich für Google Scripts)
    http.addHeader("User-Agent", "ESP32");
    
    // Timeout erhöhen für langsamere Verbindungen
    http.setTimeout(10000);
    
    int httpResponseCode = http.GET();
    
    if (httpResponseCode == 200) {
      String response = http.getString();
      Serial.println("Daten erfolgreich gesendet");
      Serial.println("Response: " + response);
    } else if (httpResponseCode == 302) {
      // Umleitung manuell behandeln
      String location = http.getLocation();
      Serial.println("Umleitung zu: " + location);
      
      http.end();
      
      // Neue Anfrage an umgeleitete URL
      if (location.length() > 0) {
        http.begin(location);
        http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
        http.addHeader("User-Agent", "ESP32");
        
        int newResponseCode = http.GET();
        if (newResponseCode == 200) {
          Serial.println("Daten nach Umleitung erfolgreich gesendet");
          String response = http.getString();
          Serial.println("Response: " + response);
        } else {
          Serial.printf("Fehler nach Umleitung: HTTP %d\n", newResponseCode);
        }
      }
    } else {
      Serial.printf("Fehler beim Senden: HTTP %d\n", httpResponseCode);
      
      // Zusätzliche Debugging-Informationen
      if (httpResponseCode < 0) {
        Serial.println("Verbindungsfehler - prüfe WLAN und URL");
      }
    }
    
    http.end();
  } else {
    Serial.println("Keine WLAN-Verbindung für Datenübertragung.");
  }
}

void updateSensorDisplay() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Text für unteres Panel formatieren (Status) - nur beim ersten Aufruf
    if (lowerTextLength == 0) {
      char sensorText[75];
      sprintf(sensorText, "      Temperatur wird gemessen");
      
      strcpy((char*)lowerTextBuffer, sensorText);
      lowerTextLength = strlen((char*)lowerTextBuffer);
      lowerTextWidth = lowerTextLength * 6;
      
      lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
      lowerScrollCount = 0;
      lowerScrollCompleted = false;
    }
    
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

void updateTemperatureDisplay() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Temperaturtext für oberes Panel (scrollend) erstellen
    char tempText[75];
    if (temperaturVerfuegbar) {
      sprintf(tempText, "      Aktuell: %.1f°C", aktuelleTemperatur);
    } else {
      sprintf(tempText, "      Temperatur wird gemessen...");
    }
    
    // Text für oberes Panel setzen
    strcpy((char*)upperTextBuffer, tempText);
    upperTextLength = strlen((char*)upperTextBuffer);
    upperTextWidth = upperTextLength * 6;
    
    // Text IMMER sofort setzen, nicht auf Scroll-Zyklen warten
    upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
    upperScrollCount = 0;
    upperScrollCompleted = false;
    
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

void forceUpdateTemperatureDisplay() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Temperaturtext für oberes Panel erstellen
    char tempText[75];
    if (temperaturVerfuegbar) {
      sprintf(tempText, "      Aktuell: %.1f°C", aktuelleTemperatur);
    } else {
      sprintf(tempText, "      Temperatur wird gemessen...");
    }
    
    // Prüfen ob sich der Text tatsächlich geändert hat
    bool textHatSichGeaendert = (strcmp((char*)upperTextBuffer, tempText) != 0);
    
    if (textHatSichGeaendert) {
      // Text für oberes Panel setzen
      strcpy((char*)upperTextBuffer, tempText);
      upperTextLength = strlen((char*)upperTextBuffer);
      upperTextWidth = upperTextLength * 6;
      
      // SOFORTIGE Aktualisierung - Text wird neu gesetzt
      upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
      upperScrollCount = 0;
      upperScrollCompleted = false;
      
      // Merken welche Temperatur angezeigt wird
      letzteAngezeigeTemperatur = temperaturVerfuegbar ? aktuelleTemperatur : -999.0;
      neueTemperaturVerfuegbar = false;
      
      Serial.println("Temperaturanzeige sofort aktualisiert (Text geändert)!");
    } else {
      Serial.println("Temperaturanzeige: Text unverändert, kein Reset");
    }
    
    ledUpdateInProgress = false;
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

void updateTemperatureDisplayOnlyAtStart() {
  // Nur aktualisieren wenn:
  // 1. Eine neue Temperatur verfügbar ist UND
  // 2. Der obere Scroll komplett durchgelaufen ist (oder das erste Mal)
  if (neueTemperaturVerfuegbar && (upperScrollCompleted || upperScrollCount == 0)) {
    if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
      ledUpdateInProgress = true;
      
      // Temperaturtext für oberes Panel erstellen
      char tempText[75];
      if (temperaturVerfuegbar) {
        sprintf(tempText, "      Aktuell: %.1f°C", aktuelleTemperatur);
      } else {
        sprintf(tempText, "      Temperatur wird gemessen...");
      }
      
      // Text für oberes Panel setzen
      strcpy((char*)upperTextBuffer, tempText);
      upperTextLength = strlen((char*)upperTextBuffer);
      upperTextWidth = upperTextLength * 6;
      
      // Text neu starten
      upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
      upperScrollCount = 0;
      upperScrollCompleted = false;
      
      // Status aktualisieren
      letzteAngezeigeTemperatur = temperaturVerfuegbar ? aktuelleTemperatur : -999.0;
      neueTemperaturVerfuegbar = false;
      
      Serial.println("Temperatur am Scroll-Anfang aktualisiert!");
      
      ledUpdateInProgress = false;
      xSemaphoreGive(ledMatrixSemaphore);
    }
  }
}

// ================= SNAKE GAME FUNKTIONEN =================

bool isOnBorder(int x, int y) {
  return (x < SNAKE_BORDER_SIZE || x >= MATRIX_WIDTH - SNAKE_BORDER_SIZE || 
          y < SNAKE_BORDER_SIZE || y >= MATRIX_HEIGHT * 2 - SNAKE_BORDER_SIZE);
}

void readJoystick() {
  int x = taster.leseY() - 2048;  // X-Bewegung vom Y-Pin des Joysticks
  int y = taster.leseX() - 2048;  // Y-Bewegung vom X-Pin des Joysticks
  
  if (abs(x) > abs(y)) {
    if (x > SNAKE_DEADZONE && dirX != -1) { dirX = 1; dirY = 0; }
    else if (x < -SNAKE_DEADZONE && dirX != 1) { dirX = -1; dirY = 0; }
  } else {
    // Y-Richtung für die korrekte Steuerung anpassen
    if (y > SNAKE_DEADZONE && dirY != 1) { dirX = 0; dirY = -1; }  // Nach oben -> dirY = -1
    else if (y < -SNAKE_DEADZONE && dirY != -1) { dirX = 0; dirY = 1; }  // Nach unten -> dirY = 1
  }
}

void moveSnake() {
  // Prüfen, ob der nächste Schritt in die Wand führen würde
  int nextX = snake[0].x + dirX;
  int nextY = snake[0].y + dirY;
  
  // Wenn der nächste Schritt auf den Rand führt, Game Over
  if (isOnBorder(nextX, nextY)) {
    gameOver = true;
    respawnTime = millis();
    return;
  }
  
  // Prüfen ob Futter gefressen wird
  bool foodEaten = (nextX == food.x && nextY == food.y);
  
  // Alte Schwanz-Position speichern für korrektes Löschen
  Point oldTail = snake[snakeLength - 1];
  
  // Schlange bewegen (nur wenn kein Game Over)
  for (int i = snakeLength - 1; i > 0; i--) {
    snake[i] = snake[i - 1];
  }
  
  snake[0].x = nextX;
  snake[0].y = nextY;
  
  // Wenn Futter gefressen wurde
  if (foodEaten) {
    if (snakeLength < 511) {
      snakeLength++;
      // Den alten Schwanz wieder hinzufügen (Schlange wird länger)
      snake[snakeLength - 1] = oldTail;
    }
    spawnFood();
  }
}

void checkCollision() {
  // Kollision mit sich selbst
  for (int i = 1; i < snakeLength; i++) {
    if (snake[0].x == snake[i].x && snake[0].y == snake[i].y) {
      gameOver = true;
      respawnTime = millis();
      return;
    }
  }
}

void spawnFood() {
  bool valid = false;
  while (!valid) {
    food.x = random(SNAKE_BORDER_SIZE + 1, MATRIX_WIDTH - SNAKE_BORDER_SIZE - 1);
    food.y = random(SNAKE_BORDER_SIZE + 1, MATRIX_HEIGHT * 2 - SNAKE_BORDER_SIZE - 1);
    
    valid = true;
    
    if (isOnBorder(food.x, food.y)) {
      valid = false;
      continue;
    }
    
    for (int i = 0; i < snakeLength; i++) {
      if (snake[i].x == food.x && snake[i].y == food.y) {
        valid = false;
        break;
      }
    }
  }
}

void setLED(uint8_t x, uint8_t y, CRGB color) {
  if (x >= MATRIX_WIDTH || y >= MATRIX_HEIGHT * 2) return;
  
  if (y < MATRIX_HEIGHT) {
    // Oberes Panel - nur bei Snake Game vertikal spiegeln
    if (aktuelleTaskNummer == 0) { // Snake Game
      // Nur vertikale Spiegelung für das obere Panel
      uint8_t rotatedY = MATRIX_HEIGHT - 1 - y;
      upperMatrix(x, rotatedY) = color;
    } else {
      // Normale Darstellung für andere Tasks
      upperMatrix(x, y) = color;
    }
  } else {
    // Unteres Panel (umgedreht)
    uint8_t localY = y - MATRIX_HEIGHT;
    lowerMatrix(x, MATRIX_HEIGHT - 1 - localY) = color;
  }
}

void drawSnakeGame() {
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    ledUpdateInProgress = true;
    
    // Alle LEDs komplett löschen
    FastLED.clear();
    
    // Gelben Rand zeichnen
    for (int x = 0; x < MATRIX_WIDTH; x++) {
      for (int y = 0; y < MATRIX_HEIGHT * 2; y++) {
        if (isOnBorder(x, y)) {
          setLED(x, y, CRGB::Yellow);
        }
      }
    }
    
    // Food zeichnen (nur wenn nicht auf Rand)
    if (!isOnBorder(food.x, food.y)) {
      setLED(food.x, food.y, CRGB::Red);
    }
    
    // Snake zeichnen - Kopf und Körper separat behandeln
    for (int i = 0; i < snakeLength; i++) {
      if (!isOnBorder(snake[i].x, snake[i].y)) {
        if (i == 0) {
          // Kopf der Schlange in hellerem Grün
          setLED(snake[i].x, snake[i].y, CRGB::Lime);
        } else {
          // Körper der Schlange in dunklerem Grün
          setLED(snake[i].x, snake[i].y, CRGB::Green);
        }
      }
    }
    
    ledUpdateInProgress = false;
    FastLED.show();
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

void resetSnakeGame() {
  // Initialisiere die Schlange in der Mitte des spielbaren Bereichs
  int centerX = (MATRIX_WIDTH - 2*SNAKE_BORDER_SIZE) / 2 + SNAKE_BORDER_SIZE;
  int centerY = (MATRIX_HEIGHT * 2 - 2*SNAKE_BORDER_SIZE) / 2 + SNAKE_BORDER_SIZE;
  
  // Alle Snake-Positionen explizit zurücksetzen
  for (int i = 0; i < 512; i++) {
    snake[i] = {-1, -1}; // Ungültige Position
  }
  
  // Startposition der Schlange
  snake[0] = {centerX, centerY};
  snake[1] = {centerX - 1, centerY};
  snake[2] = {centerX - 2, centerY};
  snakeLength = 3;
  dirX = 1;
  dirY = 0;
  gameOver = false;
  
  // Sicherstellen, dass das Display komplett neu gezeichnet wird
  if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
    FastLED.clear();
    FastLED.show();
    xSemaphoreGive(ledMatrixSemaphore);
  }
}

// ================= TASK-DEFINITIONEN =================

// Snake Game Task
void SnakeGameTask(void *parameter) {
  resetSnakeGame();
  randomSeed(analogRead(33));
  spawnFood();
  
  while (1) {
    // Prüfe ob diese Task noch aktiv sein soll
    if (aktuelleTaskNummer != 0) {
      vTaskDelay(pdMS_TO_TICKS(100));
      continue;
    }
    
    if (gameOver) {
      if (millis() - respawnTime >= respawnDelay) {
        resetSnakeGame();
        spawnFood();
      }
    } else {
      readJoystick();
      
      if (millis() - lastMoveTime > moveInterval) {
        lastMoveTime = millis();
        moveSnake();
        checkCollision();
        drawSnakeGame();
      }
    }
    vTaskDelay(pdMS_TO_TICKS(10));
  }
}

// Task B: Zeigt Wetterdaten auf LED-Matrix an
void WetterTask(void *parameter) {
  while (1) {
    // Prüfe ob diese Task noch aktiv sein soll
    if (aktuelleTaskNummer != 1) {
      vTaskDelay(pdMS_TO_TICKS(100));
      continue;
    }
    
    Serial.println("Task B - Wetter");
    
    // Wetter aktualisieren
    unsigned long currentMillis = millis();
    if (currentMillis - lastWeatherUpdate >= weatherUpdateInterval || lastWeatherUpdate == 0) {
      lastWeatherUpdate = currentMillis;
      updateWeather();
    }
    
    // Wenn ein Update des Textes notwendig ist oder beim ersten Aufruf
    if (textNeedsUpdate || (upperTextLength == 0 && lowerTextLength == 0)) {
      updateDisplayWithWeather();
      textNeedsUpdate = false;
    }
    
    // Text scrollen und anzeigen
    updateScrollText();
    safeShowLEDs();
    
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// UhrzeitTask: Zeigt Uhrzeit auf LED-Matrix an 
void UhrzeitTask(void *parameter) {
  // Flag um das erste Update zu markieren
  bool ersterAufruf = true;
  
  while (1) {
    // Prüfe ob diese Task noch aktiv sein soll
    if (aktuelleTaskNummer != 2) {
      ersterAufruf = true; // Reset für nächsten Task-Wechsel
      vTaskDelay(pdMS_TO_TICKS(100));
      continue;
    }
    
    Serial.println("Task C - Uhrzeit");
    
    // Zeit aktualisieren - beim ersten Aufruf sofort, danach nach Intervall
    unsigned long currentMillis = millis();
    if (ersterAufruf || currentMillis - lastTimeUpdate >= timeUpdateInterval) {
      lastTimeUpdate = currentMillis;
      updateTimeDisplay();
      ersterAufruf = false;
    }
    
    // Spezielle Scroll-Behandlung für Uhrzeit
    if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
      ledUpdateInProgress = true;
      
      // Update oberes Panel
      upperScrollingMsg.UpdateText();
      upperScrollCount++;

      // Update unteres Panel
      lowerScrollingMsg.UpdateText();
      lowerScrollCount++;

      // Scroll-Reset-Grenzen für Task C (Uhrzeit) - etwas konservativer
      int upperResetLimit = upperTextWidth + MATRIX_WIDTH - 28; // Etwas früher reset
      int lowerResetLimit = lowerTextWidth + MATRIX_WIDTH - 28;

      // Scroll-Reset nur wenn der gesamte Text durchgelaufen ist
      if (upperScrollCount >= upperResetLimit) {
        upperScrollCount = 0;
        upperScrollCompleted = true;
        // Verwende aktuellen Buffer für nahtlosen Übergang
        upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
      }

      if (lowerScrollCount >= lowerResetLimit) {
        lowerScrollCount = 0;
        lowerScrollCompleted = true;
        lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
      }
      
      ledUpdateInProgress = false;
      xSemaphoreGive(ledMatrixSemaphore);
    }
    
    // LEDs anzeigen
    safeShowLEDs();
    
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// DHTTask: Sensordaten auslesen und senden
// DHTTask: Sensordaten auslesen und senden
void DHTTask(void *parameter) {
  // Einmalige Anzeige-Initialisierung für DHTTask
  updateSensorDisplay(); // Initialisiert nur den unteren scrollenden Text
  
  // Direkte Initialisierung der Temperaturanzeige
  aktuelleTemperatur = 0.0;
  temperaturVerfuegbar = false;
  neueTemperaturVerfuegbar = false;
  letzteAngezeigeTemperatur = -999.0;
  
  // Flag um zu verfolgen ob die Temperaturanzeige bereits initialisiert wurde
  bool temperaturDisplayInitialisiert = false;
  bool ersterSensorReadAbgeschlossen = false;
  
  while (1) {
    // Prüfe ob diese Task noch aktiv sein soll
    if (aktuelleTaskNummer != 3) {
      // Task ist nicht mehr aktiv - Reset für nächsten Aufruf
      temperaturDisplayInitialisiert = false;
      ersterSensorReadAbgeschlossen = false;
      neueTemperaturVerfuegbar = false;
      letzteAngezeigeTemperatur = -999.0;
      vTaskDelay(pdMS_TO_TICKS(100));
      continue;
    }
    
    // Beim ersten Aufruf sofort Sensor lesen (blockierend)
    if (!temperaturDisplayInitialisiert && !ersterSensorReadAbgeschlossen) {
      Serial.println("DHTTask - Erster Sensor-Read beim Start");
      
      // Sofortiger Sensor-Read beim ersten Start
      float temperatur = dht.readTemperature();
      
      if (!isnan(temperatur)) {
        Serial.printf("Erste Temperatur erfolgreich gelesen: %.2f °C\n", temperatur);
        aktuelleTemperatur = temperatur;
        temperaturVerfuegbar = true;
        neueTemperaturVerfuegbar = true;
      } else {
        Serial.println("Erster Sensor-Read fehlgeschlagen - verwende Standard-Text");
        temperaturVerfuegbar = false;
      }
      
      ersterSensorReadAbgeschlossen = true;
      lastSensorRead = millis(); // Timer für weitere Readings setzen
    }
    
    // Initialisierung der Anzeige nach dem ersten Sensor-Read
    if (!temperaturDisplayInitialisiert && ersterSensorReadAbgeschlossen) {
      updateTemperatureDisplay(); // Initialisiert den oberen scrollenden Text
      temperaturDisplayInitialisiert = true;
    }
    
    unsigned long currentMillis = millis();
    
    // Weitere Sensor-Leseanfragen (nicht-blockierend)
    if (currentMillis - lastSensorRead >= sensorReadInterval && !sensorReadRequested) {
      sensorReadRequested = true;
      sensorRequestTime = currentMillis;
      Serial.println("DHTTask - Sensor-Anfrage gestartet");
    }
    
    // Sensor-Daten lesen wenn genug Zeit vergangen ist
    if (sensorReadRequested && (currentMillis - sensorRequestTime >= sensorReadDelay)) {
      // Temperatur vom DHT22 Sensor lesen
      float temperatur = dht.readTemperature();
      
      if (isnan(temperatur)) {
        Serial.println("Fehler beim Lesen der Temperatur!");
        // Status ändern wenn vorher Temperatur verfügbar war
        if (temperaturVerfuegbar) {
          temperaturVerfuegbar = false;
          neueTemperaturVerfuegbar = true; // Markiere dass Update nötig ist
        }
      } else {
        Serial.printf("Temperatur: %.2f °C\n", temperatur);
        
        // Prüfen ob Update nötig ist
        bool statusGeaendert = !temperaturVerfuegbar;
        bool temperaturGeaendert = temperaturVerfuegbar && (abs(aktuelleTemperatur - temperatur) > 0.1);
        
        if (statusGeaendert || temperaturGeaendert) {
          aktuelleTemperatur = temperatur;
          temperaturVerfuegbar = true;
          neueTemperaturVerfuegbar = true; // Markiere dass Update nötig ist
          Serial.println("Neue Temperatur verfügbar - wartet auf Scroll-Completion");
        }
        
        // Sende Daten in separater Task um Blocking zu vermeiden
        xTaskCreate([](void* param) {
          float temp = *((float*)param);
          sendeDaten(temp);
          vTaskDelete(NULL);
        }, "SendData", 8192, &temperatur, 1, NULL);
      }
      
      sensorReadRequested = false;
      lastSensorRead = currentMillis;
    }
    
    // Temperatur-Update nur am Scroll-Anfang prüfen
    updateTemperatureDisplayOnlyAtStart();
    
    // Text für beide Panels scrollen und anzeigen
    if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
      ledUpdateInProgress = true;
      
      // Update oberes Panel (Temperatur)
      upperScrollingMsg.UpdateText();
      upperScrollCount++;

      // Update unteres Panel (Status)
      lowerScrollingMsg.UpdateText();
      lowerScrollCount++;

      // Scroll-Reset-Grenzen für DHT Task
      int upperResetLimit = upperTextWidth + MATRIX_WIDTH - 32;
      int lowerResetLimit = lowerTextWidth + MATRIX_WIDTH - 30;

      // Scroll-Reset für oberes Panel
      if (upperScrollCount >= upperResetLimit) {
        upperScrollCount = 0;
        upperScrollCompleted = true;
        // Verwende den aktuellen Buffer-Inhalt für den neuen Scroll-Durchgang
        upperScrollingMsg.SetText(upperTextBuffer, upperTextLength);
        Serial.println("Oberer Scroll komplett - bereit für Temperatur-Update");
      }

      // Scroll-Reset für unteres Panel
      if (lowerScrollCount >= lowerResetLimit) {
        lowerScrollCount = 0;
        lowerScrollCompleted = true;
        lowerScrollingMsg.SetText(lowerTextBuffer, lowerTextLength);
      }
      
      ledUpdateInProgress = false;
      xSemaphoreGive(ledMatrixSemaphore);
    }
    
    safeShowLEDs();
    
    // Reduzierte Verzögerung für schnelleres Scrolling und Updates
    vTaskDelay(pdMS_TO_TICKS(60));
  }
}

// Funktion, um zwischen den Tasks zu wechseln - THREAD-SICHER
// Funktion, um zwischen den Tasks zu wechseln - THREAD-SICHER
void wechsleTask() {
  if (xSemaphoreTake(taskSwitchSemaphore, portMAX_DELAY) == pdTRUE) {
    // LEDs komplett löschen und Text-Buffer zurücksetzen
    if (xSemaphoreTake(ledMatrixSemaphore, portMAX_DELAY) == pdTRUE) {
      ledUpdateInProgress = true;
      
      // Alle LEDs löschen
      FastLED.clear();
      
      // Text-Buffer komplett löschen
      memset(upperTextBuffer, 0, sizeof(upperTextBuffer));
      memset(lowerTextBuffer, 0, sizeof(lowerTextBuffer));
      upperTextLength = 0;
      lowerTextLength = 0;
      
      // Scroll-Zähler zurücksetzen
      upperScrollCount = 0;
      lowerScrollCount = 0;
      upperScrollCompleted = true;
      lowerScrollCompleted = true;
      
      // Text-Objekte zurücksetzen
      upperScrollingMsg.SetText((unsigned char*)"", 0);
      lowerScrollingMsg.SetText((unsigned char*)"", 0);
      
      FastLED.show(); // Sofort anzeigen (alles schwarz)
      
      ledUpdateInProgress = false;
      xSemaphoreGive(ledMatrixSemaphore);
    }
    
    // Task wechseln
    switch (aktuelleTaskNummer) {
      case 0:
        Serial.println("Wechsel zu Task B (Wetter)");
        aktuelleTaskNummer = 1;
        // Sofortiges Update für Task B erzwingen
        textNeedsUpdate = true;
        lastWeatherUpdate = 0; // Erzwinge sofortiges Wetter-Update
        break;
      case 1:
        Serial.println("Wechsel zu Task C (Uhrzeit)");
        aktuelleTaskNummer = 2;
        // Sofortiges Update für Task C erzwingen
        lastTimeUpdate = 0; // Erzwinge sofortiges Zeit-Update
        break;
      case 2:
        Serial.println("Wechsel zu DHTTask (Sensor)");
        aktuelleTaskNummer = 3;
        // Display für DHTTask explizit neu initialisieren
        vTaskDelay(pdMS_TO_TICKS(100)); // Kurz warten
        updateSensorDisplay();
        break;
      case 3:
        Serial.println("Wechsel zu Snake Game");
        aktuelleTaskNummer = 0;
        // Snake Game wird sich selbst initialisieren
        break;
    }
    
    // Längere Pause nach Task-Wechsel für saubere Initialisierung
    vTaskDelay(pdMS_TO_TICKS(200));
    xSemaphoreGive(taskSwitchSemaphore);
  }
}

// Menü-Task: Überwacht den langen Tastendruck und wechselt die Tasks
void MenuTask(void *parameter) {
  while (1) {
    taster.aktualisiere(); // Taster-Status aktualisieren
    if (taster.wurdeLangeGedrueckt()) {
      Serial.println("Langer Tastendruck erkannt. Wechsel zwischen Tasks.");
      wechsleTask();
    }
    vTaskDelay(pdMS_TO_TICKS(10)); // Kurze Verzögerung zur Entlastung des Prozessors
  }
}

// ================= SETUP & LOOP =================

void setup() {
  // Serial-Kommunikation starten
  Serial.begin(115200);
  delay(1000); // Kurze Wartezeit für den Serial-Monitor
  
  Serial.println("Starte FreeRTOS LED Matrix Projekt mit verbesserter Thread-Sicherheit");
  
  // Semaphore für Thread-Synchronisation erstellen
  ledMatrixSemaphore = xSemaphoreCreateMutex();
  taskSwitchSemaphore = xSemaphoreCreateMutex();
  
  if (ledMatrixSemaphore == NULL || taskSwitchSemaphore == NULL) {
    Serial.println("FEHLER: Semaphore konnten nicht erstellt werden!");
    while(1) delay(1000); // System anhalten
  }
  
  // DHT Sensor initialisieren
  dht.begin();
  Serial.println("DHT22 Sensor initialisiert");
  
  // FastLED initialisieren
  FastLED.addLeds<CHIPSET, LED_PIN_UPPER, COLOR_ORDER>(upperMatrix[0], upperMatrix.Size());
  FastLED.addLeds<CHIPSET, LED_PIN_LOWER, COLOR_ORDER>(lowerMatrix[0], lowerMatrix.Size());
  FastLED.setBrightness(SNAKE_BRIGHTNESS);
  FastLED.clear();
  FastLED.show();
  Serial.println("FastLED initialisiert");
  
  // LED Text-Objekte initialisieren
  upperScrollingMsg.SetFont(MatriseFontData);
  upperScrollingMsg.Init(&upperMatrix, upperMatrix.Width(), upperScrollingMsg.FontHeight() + 1, 0, 0);
  upperScrollingMsg.SetTextColrOptions(COLR_RGB | COLR_SINGLE, 0x00, 0xff, 0xff);
  
  lowerScrollingMsg.SetFont(MatriseFontData);
  lowerScrollingMsg.Init(&lowerMatrix, lowerMatrix.Width(), lowerScrollingMsg.FontHeight() + 1, 0, 0);
  lowerScrollingMsg.SetTextColrOptions(COLR_RGB | COLR_SINGLE, 0xff, 0x80, 0x00);
  Serial.println("LED Text-Objekte initialisiert");
  
  // WLAN-Verbindung aufbauen
  Serial.println("Verbinde mit WLAN...");
  WiFi.begin(ssid, password);
  
  int wifiTimeout = 0;
  while (WiFi.status() != WL_CONNECTED && wifiTimeout < 20) {
    delay(1000);
    Serial.print(".");
    wifiTimeout++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.println("WLAN verbunden!");
    Serial.print("IP-Adresse: ");
    Serial.println(WiFi.localIP());
    
    // NTP-Zeit konfigurieren
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    Serial.println("NTP-Zeit konfiguriert");
  } else {
    Serial.println();
    Serial.println("WLAN-Verbindung fehlgeschlagen!");
  }
  
  // Tasks mit erhöhten Stack-Größen erstellen
  xTaskCreatePinnedToCore(
    SnakeGameTask,
    "SnakeGameTask",
    8192,  // Erhöhte Stack-Größe
    NULL,
    2,     // Höhere Priorität für Snake Game
    &SnakeGameTaskHandle,
    1      // Core 1
  );
  
  xTaskCreatePinnedToCore(
    WetterTask,
    "WetterTask",
    8192,  // Erhöhte Stack-Größe
    NULL,
    1,
    &WetterTaskHandle,
    1      // Core 1
  );
  
  xTaskCreatePinnedToCore(
    UhrzeitTask,
    "UhrzeitTask",
    8192,  // Erhöhte Stack-Größe
    NULL,
    1,
    &UhrzeitTaskHandle,
    1      // Core 1
  );
  
  xTaskCreatePinnedToCore(
    DHTTask,
    "DHTTask",
    8192,  // Erhöhte Stack-Größe
    NULL,
    1,
    &DHTTaskHandle,
    1      // Core 1
  );
  
  xTaskCreatePinnedToCore(
    MenuTask,
    "MenuTask",
    4096,  // Kleinere Stack-Größe für Menu-Task
    NULL,
    3,     // Höchste Priorität für Menu-Task
    &MenuTaskHandle,
    0      // Core 0 (getrennt von anderen Tasks)
  );
  
  Serial.println("Alle Tasks erstellt und gestartet");
  Serial.println("System bereit!");
  Serial.println("Langer Tastendruck wechselt zwischen den Modi:");
  Serial.println("- Snake Game");
  Serial.println("- Wetter");
  Serial.println("- Uhrzeit");
  Serial.println("- DHT Sensor");
  
  // Initiale Anzeige löschen
  safeClearLEDs();
  safeShowLEDs();
}

void loop() {
  // Hauptloop bleibt leer, da alles über Tasks läuft

}
